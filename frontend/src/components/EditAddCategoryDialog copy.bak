"use client";

import * as React from 'react';
import { useState } from 'react';
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle, Box, Stack } from '@mui/material';
import { _currencyLabeledObj, _unitLabeledObj, _workLabeledObj } from 'types/dataClasses';
import * as F from 'tsui/Form';
import * as Api from 'api';
import { useTranslation } from 'react-i18next';
import { useApiFetchMany, useApiFetchOne } from './ApiDataFetch';
import ProgressIndicator from '../tsui/ProgressIndicator';
import { confirmDialog } from './ConfirmationDialog';

interface EntityButtonPopupProps {
    catalogType: 'labor' | 'material';
    actionType: 'add' | 'update' | 'archive';
    entityType: 'category' | 'subcategory' | 'item';

    entityName: string | null;
    entityMongoId: string | null

    onClose: () => void;
    onConfirm: () => void;

}


export default function AddOrEditEntityDialog(props: EntityButtonPopupProps) {
    const form = F.useForm({
        type: 'input',
    });
    const [t] = useTranslation()

    const apiData = useApiFetchOne<Api.ApiMeasurementUnit[]>({});
    const apiEntityData = useApiFetchOne<any>({});

    React.useEffect(() => {
        if (props.entityType === 'item' && props.actionType === 'add') {
            apiData.setApi({
                command: 'measurement_unit/fetch',
            });
        }
    }, [])

    React.useEffect(() => {
        if (props.actionType === 'update') {
            switch (props.catalogType) {
                case 'labor':
                    switch (props.entityType) {
                        case 'item':
                            apiEntityData.setApi({
                                command: 'labor/get_item',
                                args: { laborItemMongoId: props.entityMongoId }
                            });
                            break;
                        // case 'category':
                        //     apiEntityData.setApi({
                        //         command: 'labor/get_category',
                        //         args: { laborCategoryMongoId: props.entityMongoId }
                        //     });
                        //     break;
                        // case 'subcategory':
                        //     apiEntityData.setApi({
                        //         command: 'labor/get_subcategory',
                        //         args: { laborSubcategoryMongoId: props.entityMongoId }
                        //     });
                        //     break;
                        default:
                            break;
                    }
                    break;
                case 'material':
                    switch (props.entityType) {
                        case 'item':
                            apiEntityData.setApi({
                                command: 'material/get_item',
                                args: { materialItemMongoId: props.entityMongoId }
                            });
                            break;
                        // case 'category':
                        //     apiEntityData.setApi({
                        //         command: 'material/get_category',
                        //         args: { materialCategoryMongoId: props.entityMongoId }
                        //     });
                        //     break;
                        // case 'subcategory':
                        //     apiEntityData.setApi({
                        //         command: 'material/get_subcategory',
                        //         args: { materialSubcategoryMongoId: props.entityMongoId }
                        //     });
                        //     break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
        }
    }, [])

    console.log('apiEntityData', apiEntityData)

    const onSubmit = React.useCallback(async (evt: F.InputFormEvent) => {
        if (form.error)
            return;
        if (!evt.isData() || Object.keys(evt.data).length === 0) { //TODO everywhere by this way
            props.onClose()
            return;
        }

        if (!evt.data.entityName)
            return

        Api.requestSession<any>({
            command: `${props.catalogType}/${props.actionType}_${props.entityType}`,
            args: {
                entityName: evt.data.entityName,
                entityCode: evt.data.entityCode ?? undefined,
                entityMongoId: props.entityMongoId,
                measurementUnitId: evt.data.measurementUnitId ?? undefined
            }
        })
            .then(d => {
                props.onConfirm();
            }).catch();
    }, [])

    // React.useEffect(() => {
    //     if (props.actionType === 'archive') {
    //         confirmDialog('Are you sure you want to archive it?').then((result) => {
    //             if (result.isConfirmed) {
    //                 Api.requestSession<any>({
    //                     command: `${props.catalogType}/${props.actionType}_${props.entityType}`,
    //                 }).then((d) => {
    //                     props.onClose();
    //                 });
    //             }else{
    //                 props.onClose();
    //             }
    //         });
    //     }
    // }, [props.actionType]);

    // if (props.actionType === 'archive') {
    //     return <></>;
    // }

    if (props.entityType === 'item' && props.actionType === 'add' && apiData.loading) {
        return <ProgressIndicator show={apiData.loading} background='backdrop' />
    }


    return (
        <F.PageFormDialog title={`${t(props.actionType) === 'update' ? t('Edit') : t('add')} ${t(props.entityType)}`} form={form} size='sm' onSubmit={onSubmit} onClose={props.onClose}>
            {props.actionType === 'add' && <F.InputText required form={form} xs={3} id='entityCode' label={t('Code')} placeholder={t('Code')} />}
            {props.actionType === 'update' && <F.InputText required form={form} value={apiEntityData?.data?.code} xs={3} id='entityCode' label={t('Code')} placeholder={t('Code')} />}
            {(props.entityType === 'item' && props.actionType === 'add') &&
                <F.SelectField
                    form={form}
                    xs={9}
                    id={`measurementUnitId`}
                    required
                    items={
                        apiData.data
                            ? apiData.data.map((unit) => ({
                                id: unit.measurementUnitId, // or use unit._id if you prefer
                                name: unit.name,
                                label: unit.name,
                            }))
                            : []
                    }
                    value={t(apiData.data?.[0]?.name ?? "Choose Measurement Unit")}
                    label={t('Measurement Unit')}
                />
            }
            {props.actionType === 'add'
                ?
                <F.InputText required form={form} xs={props.entityType === 'item' ? 12 : 9} id='entityName' label={t(`Title of ${props.entityType}`)} placeholder={t(`Title of ${props.entityType}`)} />
                :
                <F.InputText required form={form} xsMax id='entityName' value={props.entityName} label={t(`Title of ${props.entityType}`)} placeholder={t(`Title of ${props.entityType}`)} />
            }




        </F.PageFormDialog>
    );
}
